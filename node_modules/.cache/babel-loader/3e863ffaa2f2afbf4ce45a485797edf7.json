{"ast":null,"code":"import { useEffect, useState } from 'react';\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nfunction noop() {}\n\nvar stopWatching = function stopWatching(watchId) {\n  navigator.nfc.cancelWatch(watchId).then(function () {\n    console.log('Stopped watching for a nfc tag.');\n  }).catch(function (error) {\n    if (error.name === 'NotFoundError') {\n      // we're ignoring NotFoundError, assuming it happened because the\n      // watch was already cancelled after a write\n      return;\n    }\n\n    throw error;\n  });\n};\n\nfunction nfcAvailable() {\n  if (navigator.nfc) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction read() {\n  var setResponse = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;\n  var timeout = arguments[1];\n\n  if (!nfcAvailable()) {\n    setResponse(function (prevState) {\n      return _extends({}, prevState, {\n        status: 'UNAVAILABLE'\n      });\n    });\n    return;\n  }\n\n  setResponse(function (prevState) {\n    return _extends({}, prevState, {\n      status: 'INITIALIZING'\n    });\n  });\n  navigator.nfc.watch(function (message) {\n    setResponse(function (prevState) {\n      return _extends({}, prevState, {\n        data: message.records[0].data\n      });\n    });\n  }).then(function (watchId) {\n    var timeoutId = setTimeout(function () {\n      stopWatching(watchId);\n      setResponse(function (prevState) {\n        return _extends({}, prevState, {\n          status: 'TIMEOUT'\n        });\n      });\n    }, timeout * 1000);\n    var intervalId = setInterval(function () {\n      setResponse(function (prevState) {\n        return _extends({}, prevState, {\n          time: prevState.time - 1\n        });\n      });\n    }, 1000);\n    setResponse(function (prevState) {\n      return _extends({}, prevState, {\n        status: 'READY',\n        time: timeout,\n        retry: function retry() {\n          clearTimeout(timeoutId);\n          clearInterval(intervalId);\n          stopWatching(watchId);\n          read(setResponse, timeout);\n        }\n      });\n    });\n  });\n}\n\nfunction useNfcRead() {\n  var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 15;\n\n  var _useState = useState({\n    retry: noop\n  }),\n      _useState2 = slicedToArray(_useState, 2),\n      response = _useState2[0],\n      setResponse = _useState2[1];\n\n  useEffect(function () {\n    read(setResponse, timeout);\n    return function () {\n      return stopWatching();\n    };\n  }, []);\n  return response;\n}\n\nexport { useNfcRead };","map":{"version":3,"sources":["../src/index.js"],"names":["stopWatching","error","navigator","setResponse","noop","timeout","nfcAvailable","message","data","timeoutId","intervalId","prevState","response","useState","retry"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,SAAA,IAAA,GAAgB,CAAA;;AAEhB,IAAMA,YAAAA,GAAe,SAAfA,YAAe,CAAA,OAAA,EAAW;YAC9B,G,CAAA,W,CAAA,O,EAAA,I,CAEQ,YAAM;YACV,G,CAAA,iC;AAHJ,G,EAAA,K,CAKS,UAAA,KAAA,EAAS;QACVC,KAAAA,CAAAA,IAAAA,KAAJ,e,EAAoC;;;;;;UAKpC,K;AAXJ,G;AADF,CAAA;;AAgBA,SAAA,YAAA,GAAwB;MAClBC,SAAAA,CAAJ,G,EAAmB;WACjB,I;;;SAEF,K;;;AAGF,SAAA,IAAA,GAA2C;MAA7BC,WAA6B,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAfC,I;MAAMC,OAAS,GAAA,SAAA,CAAA,CAAA,C;;MACrC,CAACC,YAAL,E,EAAqB;gBACP,UAAA,SAAA,EAAA;0BAAA,S,EAAA;gBAEF;AAFE,O;AAAZ,K;;;;cAMU,UAAA,SAAA,EAAA;wBAAA,S,EAAA;cAEF;AAFE,K;AAAZ,G;YAIA,G,CAAA,K,CACS,UAAA,OAAA,EAAW;gBACJ,UAAA,SAAA,EAAA;0BAAA,S,EAAA;cAEJC,OAAAA,CAAAA,OAAAA,CAAAA,CAAAA,EAAmBC;AAFf,O;AAAZ,K;AAFJ,G,EAAA,I,CAOQ,UAAA,OAAA,EAAW;QACTC,SAAAA,GAAY,UAAA,CAAW,YAAM;mBACjC,O;kBACY,UAAA,SAAA,EAAA;4BAAA,S,EAAA;kBAEF;AAFE,S;AAAZ,O;AAFgB,KAAA,EAMfJ,OAAAA,GANH,IAAkB,C;QAOZK,UAAAA,GAAa,WAAA,CAAY,YAAM;kBACvB,UAAA,SAAA,EAAA;4BAAA,S,EAAA;gBAEJC,SAAAA,CAAAA,IAAAA,GAAiB;AAFb,S;AAAZ,O;AADiB,KAAA,EAAnB,IAAmB,C;gBAMP,UAAA,SAAA,EAAA;0BAAA,S,EAAA;gBAAA,OAAA;cAAA,OAAA;eAIH,SAAA,KAAA,GAAM;uBACX,S;wBACA,U;uBACA,O;eACA,W,EAAA,O;;AARQ,O;AAAZ,K;AArBJ,G;;;AAmCF,SAAA,UAAA,GAAkC;MAAdN,OAAc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,E;;kBACIQ,QAAAA,CAAS;AAAEC,IAAAA,KAAAA,EADX;AACS,GAATD,C;;MAAzBD,QADyB,GAAA,UAAA,CAAA,CAAA,C;MACfT,WADe,GAAA,UAAA,CAAA,CAAA,C;;YAEtB,YAAM;SACd,W,EAAA,O;WACO,YAAA;aAAMH,YAAN,E;AAAP,K;AAFF,G,EAAA,E;SAIA,Q","sourcesContent":["import { useEffect, useState } from 'react'\n\nfunction noop() {}\n\nconst stopWatching = watchId => {\n  navigator.nfc\n    .cancelWatch(watchId)\n    .then(() => {\n      console.log('Stopped watching for a nfc tag.')\n    })\n    .catch(error => {\n      if (error.name === 'NotFoundError') {\n        // we're ignoring NotFoundError, assuming it happened because the\n        // watch was already cancelled after a write\n        return\n      }\n      throw error\n    })\n}\n\nfunction nfcAvailable() {\n  if (navigator.nfc) {\n    return true\n  }\n  return false\n}\n\nfunction read(setResponse = noop, timeout) {\n  if (!nfcAvailable()) {\n    setResponse(prevState => ({\n      ...prevState,\n      status: 'UNAVAILABLE',\n    }))\n    return\n  }\n  setResponse(prevState => ({\n    ...prevState,\n    status: 'INITIALIZING',\n  }))\n  navigator.nfc\n    .watch(message => {\n      setResponse(prevState => ({\n        ...prevState,\n        data: message.records[0].data,\n      }))\n    })\n    .then(watchId => {\n      const timeoutId = setTimeout(() => {\n        stopWatching(watchId)\n        setResponse(prevState => ({\n          ...prevState,\n          status: 'TIMEOUT',\n        }))\n      }, timeout * 1000)\n      const intervalId = setInterval(() => {\n        setResponse(prevState => ({\n          ...prevState,\n          time: prevState.time - 1,\n        }))\n      }, 1000)\n      setResponse(prevState => ({\n        ...prevState,\n        status: 'READY',\n        time: timeout,\n        retry: () => {\n          clearTimeout(timeoutId)\n          clearInterval(intervalId)\n          stopWatching(watchId)\n          read(setResponse, timeout)\n        },\n      }))\n    })\n}\n\nfunction useNfcRead(timeout = 15) {\n  const [response, setResponse] = useState({ retry: noop })\n  useEffect(() => {\n    read(setResponse, timeout)\n    return () => stopWatching()\n  }, [])\n  return response\n}\n\nexport { useNfcRead }\n"]},"metadata":{},"sourceType":"module"}