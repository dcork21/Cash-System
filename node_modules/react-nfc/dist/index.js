'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

function noop() {}

var stopWatching = function stopWatching(watchId) {
  navigator.nfc.cancelWatch(watchId).then(function () {
    console.log('Stopped watching for a nfc tag.');
  }).catch(function (error) {
    if (error.name === 'NotFoundError') {
      // we're ignoring NotFoundError, assuming it happened because the
      // watch was already cancelled after a write
      return;
    }
    throw error;
  });
};

function nfcAvailable() {
  if (navigator.nfc) {
    return true;
  }
  return false;
}

function read() {
  var setResponse = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;
  var timeout = arguments[1];

  if (!nfcAvailable()) {
    setResponse(function (prevState) {
      return _extends({}, prevState, {
        status: 'UNAVAILABLE'
      });
    });
    return;
  }
  setResponse(function (prevState) {
    return _extends({}, prevState, {
      status: 'INITIALIZING'
    });
  });
  navigator.nfc.watch(function (message) {
    setResponse(function (prevState) {
      return _extends({}, prevState, {
        data: message.records[0].data
      });
    });
  }).then(function (watchId) {
    var timeoutId = setTimeout(function () {
      stopWatching(watchId);
      setResponse(function (prevState) {
        return _extends({}, prevState, {
          status: 'TIMEOUT'
        });
      });
    }, timeout * 1000);
    var intervalId = setInterval(function () {
      setResponse(function (prevState) {
        return _extends({}, prevState, {
          time: prevState.time - 1
        });
      });
    }, 1000);
    setResponse(function (prevState) {
      return _extends({}, prevState, {
        status: 'READY',
        time: timeout,
        retry: function retry() {
          clearTimeout(timeoutId);
          clearInterval(intervalId);
          stopWatching(watchId);
          read(setResponse, timeout);
        }
      });
    });
  });
}

function useNfcRead() {
  var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 15;

  var _useState = react.useState({ retry: noop }),
      _useState2 = slicedToArray(_useState, 2),
      response = _useState2[0],
      setResponse = _useState2[1];

  react.useEffect(function () {
    read(setResponse, timeout);
    return function () {
      return stopWatching();
    };
  }, []);
  return response;
}

exports.useNfcRead = useNfcRead;
//# sourceMappingURL=index.js.map
